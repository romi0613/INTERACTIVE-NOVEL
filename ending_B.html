<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>ENDING B — 끝나지 않는 밤</title>

  <!-- 폰트 -->
  <link rel="stylesheet"
        href="https://cdn.jsdelivr.net/gh/orioncactus/pretendard/dist/web/variable/pretendardvariable.css"/>

  <style>
    :root{
      --ink:#f7f0e6;
      --muted:#b8aa9e;
      --border-soft:#ffffff26;
      --bg-main:#050309;
      --bg-card:#120910;
    }

    /* ===== 엔딩별 테마 ===== */
    body.theme-loop{  /* ENDING B용 (보라/네온 루프 느낌) */
      --accent-main:#9a84ff;
      --accent-strong:#d2c8ff;
      --accent-pill:#fcf8fa;
      --bg-grad-1:#261c4a;
      --bg-grad-2:#070b20;
    }

    *{box-sizing:border-box}
    html,body{height:100%}
    body{
      margin:0;
      font-family:'Pretendard Variable',system-ui,-apple-system,BlinkMacSystemFont,"Segoe UI",sans-serif;
      color:var(--ink);
      background:
        radial-gradient(circle at 0% 0%, var(--bg-grad-1) 0, var(--bg-main) 40%, #020104 100%),
        radial-gradient(circle at 110% 120%, var(--bg-grad-2) 0, var(--bg-main) 55%);
      display:flex;
      align-items:center;
      justify-content:center;
      padding:24px;
    }

    .ending-frame{
      width:min(1040px, 96vw);
      max-height:92vh;
      border-radius:22px;
      border:1px solid var(--border-soft);
      background:
        radial-gradient(circle at 0% 0%, rgba(180,160,255,.12) 0, transparent 60%),
        radial-gradient(circle at 120% 110%, rgba(120,110,255,.18) 0, transparent 60%),
        linear-gradient(135deg,#0f0b19,#05020c);
      box-shadow:
        0 26px 90px rgba(0,0,0,.9),
        0 0 60px rgba(0,0,0,.7);
      padding:24px 28px 18px;
      display:flex;
      flex-direction:column;
      overflow:hidden;
    }

    /* ===== 상단 헤더 ===== */
    .ending-header{
      display:flex;
      justify-content:space-between;
      align-items:flex-start;
      margin-bottom:12px;
      gap:16px;
    }

    .brand-block{
      display:flex;
      flex-direction:column;
      gap:4px;
    }
    .brand-title{
      font-size:clamp(18px,2.2vw,22px);
      letter-spacing:.4em;
      text-indent:.4em;
      font-weight:800;
      color:var(--accent-strong);
      text-shadow:
        0 0 10px rgba(210,200,255,.9),
        0 0 22px rgba(90,80,255,.7);
      white-space:nowrap;
    }
    .brand-sub{
      font-size:.72rem;
      letter-spacing:.22em;
      text-transform:uppercase;
      color:var(--muted);
    }

    .ending-meta-top{
      text-align:right;
      font-size:.75rem;
      letter-spacing:.18em;
      text-transform:uppercase;
      color:var(--muted);
    }
    .ending-meta-top strong{
      display:block;
      margin-top:4px;
      color:var(--accent-strong);
    }

    /* ===== 메인 카드 ===== */
    .ending-card{
      flex:1;
      border-radius:18px;
      border:1px solid #ffffff22;
      background:
        radial-gradient(circle at 0% 0%, rgba(180,170,255,.12) 0, transparent 55%),
        linear-gradient(135deg, #141020, #05040f 70%, #04030b 100%);
      padding:20px 22px 18px;
      display:flex;
      flex-direction:column;
      overflow:auto;
    }

    .kicker{
      font-size:.78rem;
      letter-spacing:.3em;
      text-transform:uppercase;
      color:var(--muted);
      margin-bottom:6px;
    }
    .ending-name{
      margin:0 0 10px;
      font-size:clamp(26px,3.2vw,34px);
      line-height:1.15;
      color:var(--accent-strong);
      text-shadow:0 0 24px rgba(160,130,255,.25);
    }
    .status-line{
      font-size:.8rem;
      letter-spacing:.16em;
      text-transform:uppercase;
      color:var(--muted);
      padding-bottom:12px;
      border-bottom:1px solid #ffffff1f;
      margin-bottom:14px;
    }
    .status-line #routeDepth{
      color:var(--accent-strong);
      font-weight:700;
    }

    .summary{
      font-size:.96rem;
      line-height:1.9;
      color:var(--ink);
    }
    .summary p{margin:.45em 0;}
    .summary p.lead{
      font-size:1.02rem;
      color:#f9efe3;
    }

    /* 선택 경로/요약 */
    .route-text{
      margin-top:10px;
      font-size:.9rem;
      line-height:1.7;
      color:var(--muted);
    }
    .route-text strong{color:var(--accent-strong);}

    /* ===== 아래 정보 그리드 ===== */
    .ending-grid{
      margin-top:16px;
      display:grid;
      grid-template-columns:1.25fr 1fr;
      gap:16px;
    }

    .panel{
      border-radius:12px;
      border:1px solid rgba(255,255,255,.12);
      background:rgba(0,0,0,.26);
      padding:12px 14px;
      font-size:.9rem;
    }
    .panel h2{
      margin:0 0 6px;
      font-size:.82rem;
      letter-spacing:.18em;
      text-transform:uppercase;
      color:var(--accent-pill);
    }
    .panel p{
      margin:0;
      color:var(--muted);
      line-height:1.7;
      font-size:.88rem;
    }

    .panel ul{
      margin:4px 0 0;
      padding-left:1.1em;
      list-style:disc;
      color:var(--muted);
      line-height:1.7;
      font-size:.86rem;
    }
    .panel ul li + li{margin-top:2px;}

    .panel-wide{
      grid-column:1/-1;
      margin-top:6px;
      background:
        radial-gradient(circle at 0 0, rgba(160,120,255,.16) 0, rgba(5,4,16,1) 55%);
    }
    .panel-wide h2{color:var(--accent-pill);}

    /* ===== 버튼 / 푸터 ===== */
    .footer{
      margin-top:14px;
      padding-top:10px;
      border-top:1px solid #ffffff1f;
      display:flex;
      flex-direction:column;
      gap:10px;
    }
    .btn-row{
      display:flex;
      flex-wrap:wrap;
      gap:10px;
    }
    .btn{
      border-radius:999px;
      padding:8px 18px;
      border:1px solid #ffffff33;
      background:transparent;
      color:var(--ink);
      font-size:.85rem;
      letter-spacing:.04em;
      display:inline-flex;
      align-items:center;
      gap:6px;
      cursor:pointer;
    }
    .btn.primary{
      background:var(--accent-main);
      border-color:var(--accent-main);
      color:#0e081c;
      font-weight:600;
    }
    .btn span.icon{font-size:.9rem;}
    .btn:hover{
      border-color:var(--accent-main);
      box-shadow:0 0 18px rgba(170,150,255,.5);
    }
    .footer-note{
      font-size:.78rem;
      color:var(--muted);
    }

    @media (max-width:720px){
      body{padding:14px;}
      .ending-frame{padding:18px 16px;}
      .ending-grid{grid-template-columns:1fr;}
    }
  </style>
</head>

<body class="theme-loop">
  <div class="ending-frame">
    <!-- 상단 -->
    <header class="ending-header">
      <div class="brand-block">
        <div class="brand-title">BANDERSNATCH</div>
        <div class="brand-sub">ENDING ARCHIVE</div>
      </div>
      <div class="ending-meta-top">
        <span>INTERACTIVE NOVEL</span>
        <strong>ENDING B · LOOP</strong>
      </div>
    </header>

    <!-- 메인 카드 -->
    <section class="ending-card">
      <div class="kicker">ENDING B</div>
      <h1 class="ending-name">끝나지 않는 밤</h1>

      <div class="status-line">
        STATUS · UNLOCKED · ROUTE DEPTH : <span id="routeDepth">0</span>
      </div>

      <div class="summary">
        <p class="lead">
          밤은 몇 번이고 끝났다고 말하지만, 화면의 시계와 알림창은 계속해서 같은 시간을 가리킨다.
        </p>
        <p>
          사건은 해결된 것처럼 보이고, 뉴스에서는 더 이상 도살자의 이름을 언급하지 않는다.
          하지만 당신이 되감기 버튼을 누를 때마다, 대사와 장면들은 미세하게 뒤틀린 채
          처음으로 되돌아간다. 이 엔딩에서 주인공은 진실 대신
          <strong>“다시 하기”라는 선택지</strong>에 갇힌다.
        </p>

        <!-- path(루트)에 따라 바뀌는 짧은 설명 -->
        <p id="routeIntro"></p>

        <!-- 이번 플레이의 선택 문자열 요약 -->
        <p id="routeSummary" class="route-text"></p>
      </div>

      <div class="ending-grid">
        <section class="panel">
          <h2>YOUR KEY CHOICES</h2>
          <ul id="keyChoices"></ul>
        </section>

        <section class="panel">
          <h2>WHAT THIS ENDING MEANS</h2>
          <p>
            이 엔딩은 “완벽한 결론”이 아니라 <strong>결정을 미루는 습관</strong>이 만든 반복입니다.
            다시 시작할 수 있다는 편안함이, 오히려 밤을 끝낼 단 한 번의 용기를 지워버립니다.
          </p>
        </section>

        <section class="panel panel-wide">
          <h2>IF YOU HAD CHOSEN DIFFERENTLY…</h2>
          <ul id="diffChoices">
            <li>초반에 책을 챙기고, 사건 기사들을 끝까지 읽었다면
              보다 직접적으로 진실을 마주하는 <strong>ENDING A</strong>에 가까워졌을 것입니다.</li>
            <li>마지막 갈림길에서 누군가를 지키기 위해 스스로를 내던지는 선택을 했다면,
              희생을 전제로 한 <strong>ENDING C</strong>로 이어졌을 가능성이 큽니다.</li>
            <li>되감기와 선택 반복 중에 “이게 게임 같다”는 메타적인 선택지만 골라 눌렀다면,
              스스로가 이야기 바깥에 있다는 걸 깨닫는 <strong>ENDING D</strong>로 갈 수 있었을지도 모릅니다.</li>
          </ul>
        </section>
      </div>

      <footer class="footer">
        <div class="btn-row">
          <button class="btn primary" onclick="location.href='Start.html'">
            <span class="icon">↺</span>
            처음부터 다시 시작
          </button>
          <button class="btn" onclick="location.href='지난선택.html'">
            <span class="icon">☷</span>
            지난 선택 보기
          </button>
          <button class="btn" onclick="location.href='참고.html'">
            <span class="icon">✦</span>
            엔딩 모음집
          </button>
        </div>

        <div class="footer-note">
          이 엔딩을 보면 <strong>ENDING B</strong>가 자동으로 해금되어
          <em>지난 선택 보기</em>와 <em>엔딩 모음집</em> 화면에서 확인할 수 있습니다.
        </div>
      </footer>
    </section>
  </div>

  <script>
    function getParam(name){
      const params = new URLSearchParams(location.search);
      return params.get(name);
    }

    function normalizePath(raw){
      return (raw || '')
        .toUpperCase()
        .replace(/[^AB]/g, '');
    }

    function prettyPath(path){
      return path.split('').join(' → ');
    }

    document.addEventListener('DOMContentLoaded', () => {
      // 해금 기록
      try{
        localStorage.setItem('ending:ENDING_B','1');
      }catch(e){}

      const rawPath = getParam('path') || '';
      const fullPath = normalizePath(rawPath);

      // ROUTE DEPTH는 '누적 선택 수' 기준 (첫번째 파일 로직 유지)
      const depthEl = document.getElementById('routeDepth');
      if(depthEl) depthEl.textContent = String(fullPath.length);

      // routeSummary
      const summaryEl = document.getElementById('routeSummary');
      if(summaryEl){
        if(fullPath){
          summaryEl.innerHTML = `이번 플레이에서 당신은 <strong>${prettyPath(fullPath)}</strong> 순서로 선택해 이 엔딩에 도달했습니다.`;
        }else{
          summaryEl.textContent = '이번 플레이의 선택 기록을 찾지 못했습니다. (path 파라미터가 비어있을 수 있어요)';
        }
      }

      // 루트 소개는 "마지막 두 선택"을 기준으로 분기 (길이가 2보다 길어도 대응)
      const key = (fullPath.length >= 2) ? fullPath.slice(-2) : fullPath.padEnd(2,'A');

      const routeIntro = document.getElementById('routeIntro');
      const keyChoices = document.getElementById('keyChoices');

      const routes = {
        'AA': {
          intro: '진실에 닿을 수 있었던 루트였지만, 마지막까지 결정을 미루는 선택이 겹치며 밤은 끝나지 않았습니다. 당신은 “조금만 더”를 반복하다가, 결국 루프 안에 남았습니다.',
          choices: [
            '결정적인 순간에 한 발 물러섰다.',
            '확신이 서기 전까지는 “다시 하기”를 눌렀다.',
            '진실보다 안전한 반복을 선택했다.'
          ]
        },
        'AB': {
          intro: '처음부터 사건과 거리를 두었고, 마지막 선택에서도 안전해 보이는 쪽만 골랐습니다. 그 결과 이야기는 결말을 내지 못한 채, 같은 밤을 복사해 붙여넣듯 반복됩니다.',
          choices: [
            '관여하기보단 거리를 두었다.',
            '위험을 피하는 선택을 우선했다.',
            '결론 대신 ‘유지’를 택했다.'
          ]
        },
        'BA': {
          intro: '중간에 한 번은 깊이 관여하려 했지만, 곧바로 되돌리거나 다른 선택을 시도했습니다. 여러 루트를 뒤섞는 과정에서, 시스템은 당신을 “테스트 중인 플레이어”로 분류하고 루프에 가둡니다.',
          choices: [
            '한 번은 과감히 들어갔다.',
            '하지만 곧 되감기/수정으로 방향을 틀었다.',
            '결정의 책임을 분산시키려 했다.'
          ]
        },
        'BB': {
          intro: '철저하게 아무 책임도 지지 않으려 한 끝에, 당신은 가장 길고 조용한 벌을 받게 됩니다. 화면을 끄는 순간마다, 같은 밤의 첫 장면으로 돌아옵니다.',
          choices: [
            '책임을 피하는 선택을 반복했다.',
            '누군가를 구하기보다 “나만 빠져나오기”를 택했다.',
            '끝을 내기보다 종료/회피를 눌렀다.'
          ]
        }
      };

      const fallback = {
        intro: '여러 갈림길에서 애매한 선택을 반복한 끝에, 이야기는 하나의 결말이 아니라 끝나지 않는 재생 목록처럼 변해 버렸습니다.',
        choices: [
          '명확한 결정보다 유예를 택했다.',
          '되감기와 반복으로 시간을 늘렸다.',
          '결말 대신 “루프”에 머물렀다.'
        ]
      };

      const data = routes[key] || fallback;

      if(routeIntro) routeIntro.textContent = data.intro;

      if(keyChoices){
        keyChoices.innerHTML = '';
        for(const item of data.choices){
          const li = document.createElement('li');
          li.textContent = item;
          keyChoices.appendChild(li);
        }
      }
    });
  </script>
</body>
</html>
